LeetCode 72. Edit Distance  

üìù Question:  
Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.  

Operations allowed:  
1. Insert a character  
2. Delete a character  
3. Replace a character  

Example 1:  
Input: word1 = "horse", word2 = "ros"  
Output: 3  
Explanation:  
horse ‚Üí rorse (replace 'h' with 'r')  
rorse ‚Üí rose (remove 'r')  
rose ‚Üí ros (remove 'e')  

Example 2:  
Input: word1 = "intention", word2 = "execution"  
Output: 5  


-----------------------------------------------------------
‚úÖ Approach: Dynamic Programming  

- Define `dp[i][j]` = min operations to convert `word1[:i]` to `word2[:j]`.  
- Base cases:  
  - `dp[0][j] = j` (insert all characters)  
  - `dp[i][0] = i` (delete all characters)  
- Transition:  
  - If `word1[i-1] == word2[j-1]`: `dp[i][j] = dp[i-1][j-1]`  
  - Else: `dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])`  
    - Replace, Insert, Delete  


-----------------------------------------------------------
üíª Solution:
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # Initialize base cases
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j

        # Fill DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])

        return dp[m][n]

-----------------------------------------------------------
‚è±Ô∏è Time Complexity: O(m * n)  
   - Fill a DP table of size (m+1) x (n+1)  

üíæ Space Complexity: O(m * n)  
   - 2D DP table stores all subproblems  
-----------------------------------------------------------
