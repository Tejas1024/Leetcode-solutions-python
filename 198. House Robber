LeetCode 198. House Robber

📝 Question:  
You are a professional robber planning to rob houses along a street.  
Each house has some money stashed, but adjacent houses have security systems connected,  
so if two adjacent houses are robbed on the same night, the police will be alerted.  

Return the maximum amount of money you can rob without alerting the police.  

Example 1:  
Input: nums = [1,2,3,1]  
Output: 4  
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4  

Example 2:  
Input: nums = [2,7,9,3,1]  
Output: 12  
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9), and rob house 5 (money = 1). Total = 12  


-----------------------------------------------------------
✅ Approach: Dynamic Programming  

We cannot rob two adjacent houses.  
At each house `i`, we decide:  
- Rob this house → `nums[i] + dp[i-2]`  
- Skip this house → `dp[i-1]`  

So, recurrence:  
`dp[i] = max(dp[i-1], nums[i] + dp[i-2])`  

We only need two variables (`prev1`, `prev2`) instead of full dp array.  

⚡ Key Trick:  
Use rolling variables to reduce space from O(n) → O(1).  


-----------------------------------------------------------
💻 Solution:
class Solution:
    def rob(self, nums: list[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]
        
        prev2 = 0       # dp[i-2]
        prev1 = nums[0] # dp[i-1]
        
        for i in range(1, n):
            rob_current = nums[i] + prev2
            skip_current = prev1
            curr = max(rob_current, skip_current)
            
            # Update rolling variables
            prev2, prev1 = prev1, curr
        
        return prev1

-----------------------------------------------------------
⏱️ Time Complexity: O(n)  
   - Loop through all houses once.  

💾 Space Complexity: O(1)  
   - Only two variables used for DP state.  
-----------------------------------------------------------
