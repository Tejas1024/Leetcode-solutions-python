"""
LeetCode Problem 77: Combinations
Difficulty: Medium

--------------------------------------
ðŸ§  Problem Statement:
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.

Example 1:
Input: n = 4, k = 2
Output:
[
  [1,2],
  [1,3],
  [1,4],
  [2,3],
  [2,4],
  [3,4]
]

Example 2:
Input: n = 1, k = 1
Output: [[1]]
--------------------------------------

âœ… Approach:
We use **Backtracking**:
1. Start with an empty combination `path`.
2. At each step, decide whether to include the current number.
3. Once `path` has `k` elements, add it to the result.
4. Recursively build all valid combinations.

--------------------------------------
"""

class Solution:
    def combine(self, n: int, k: int):
        result = []   # Stores all valid combinations
        path = []     # Current combination being built

        def backtrack(start):
            # âœ… Base Case: Found a valid combination
            if len(path) == k:
                result.append(path[:])  # Copy current path
                return
            
            # Explore choices from 'start' to 'n'
            for i in range(start, n + 1):
                path.append(i)           # Choose i
                backtrack(i + 1)         # Explore further
                path.pop()               # Undo choice (Backtrack)

        backtrack(1)
        return result

"""
ðŸ“Š Time Complexity: O(C(n, k) * k)
- C(n, k) is the number of combinations.
- Each valid combination takes O(k) to build/copy.

ðŸ§  Space Complexity: O(k)
- Recursion depth and current path size is at most k.
"""
