LeetCode Problem 34: Find First and Last Position of Element in Sorted Array  
Difficulty: Medium  

-----------------------------------------------------------
Problem Statement:  
Given an array of integers nums sorted in non-decreasing order,  
find the starting and ending position of a given target value.  

If target is not found in the array, return [-1, -1].  

You must write an algorithm with O(log n) runtime complexity.  

Example 1:  
Input: nums = [5,7,7,8,8,10], target = 8  
Output: [3,4]  

Example 2:  
Input: nums = [5,7,7,8,8,10], target = 6  
Output: [-1,-1]  

Example 3:  
Input: nums = [], target = 0  
Output: [-1,-1]  
-----------------------------------------------------------  

âœ… Approach: Binary Search (twice)  
We want the first and last occurrence of target.  

1. Use binary search to find the **first occurrence**:  
   - When we find target at mid, donâ€™t stop â†’ move left to see if target exists earlier.  

2. Use binary search to find the **last occurrence**:  
   - When we find target at mid, donâ€™t stop â†’ move right to see if target exists later.  

3. Return [first, last].  

This works in O(log n) since each binary search takes log n time.  

-----------------------------------------------------------

class Solution:
    def searchRange(self, nums, target):
        def findFirst(nums, target):
            left, right = 0, len(nums) - 1
            first = -1
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    first = mid
                    right = mid - 1   # keep searching left side
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return first

        def findLast(nums, target):
            left, right = 0, len(nums) - 1
            last = -1
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    last = mid
                    left = mid + 1   # keep searching right side
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return last

        return [findFirst(nums, target), findLast(nums, target)]


-----------------------------------------------------------
ðŸ“Š Time Complexity: O(log n)  
- Each search (first and last) takes O(log n).  

ðŸ§  Space Complexity: O(1)  
- Only variables are used, no extra data structure.  
-----------------------------------------------------------
