"""
LeetCode Problem 130: Surrounded Regions

Problem Statement:
You are given an m x n matrix board containing 'X' and 'O'.
Capture all regions surrounded by 'X'. A region is captured by flipping
all 'O's into 'X's in that surrounded region.

Example:
Input:
board = [["X","X","X","X"],
         ["X","O","O","X"],
         ["X","X","O","X"],
         ["X","O","X","X"]]

Output:
[["X","X","X","X"],
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","O","X","X"]]

Explanation:
The region on the middle is surrounded, so it gets captured.
The 'O' on the border is not surrounded, so it remains.

Approach:
1. Any 'O' connected to the border cannot be flipped.
2. Start DFS/BFS from border 'O's and mark them as safe (e.g., 'S').
3. After marking, flip all remaining 'O' â†’ 'X'.
4. Convert 'S' back to 'O'.

Time Complexity: O(m * n), where m = rows, n = cols.
Space Complexity: O(m * n) in worst case for recursion/visited set.
"""

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board or not board[0]:
            return
        
        rows, cols = len(board), len(board[0])

        # DFS function to mark safe 'O's
        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'O':
                return
            board[r][c] = 'S'  # mark as safe
            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1)
        
        # Step 1: Start from borders and mark safe 'O's
        for r in range(rows):
            dfs(r, 0)
            dfs(r, cols-1)
        for c in range(cols):
            dfs(0, c)
            dfs(rows-1, c)
        
        # Step 2: Flip all remaining 'O' to 'X', and 'S' back to 'O'
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == 'O':
                    board[r][c] = 'X'
                elif board[r][c] == 'S':
                    board[r][c] = 'O'
