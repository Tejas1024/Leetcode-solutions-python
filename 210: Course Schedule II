LeetCode Problem 210: Course Schedule II
---------------------------------
Problem Statement:
There are `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`.
Some courses may have prerequisites, represented as a list of pairs `prerequisites[i] = [a, b]`, 
which means you must take course `b` before taking course `a`.

Return the ordering of courses you should take to finish all courses. 
If there are many valid answers, return any of them. 
If it is impossible to finish all courses, return an empty array.

Example 1:
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]

Example 2:
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]

Constraints:
- 1 <= numCourses <= 2000
- 0 <= prerequisites.length <= numCourses * (numCourses - 1)
- prerequisites[i].length == 2
- 0 <= ai, bi < numCourses
- All prerequisite pairs are unique.

---------------------------------
Approach:
We need to find a valid topological ordering of the courses.
1. Build a graph using adjacency lists.
2. Track the in-degree of each course (number of prerequisites).
3. Use Kahnâ€™s Algorithm (BFS approach):
   - Start with courses having in-degree 0 (no prerequisites).
   - Remove them from the graph, reducing the in-degree of dependent courses.
   - Continue until all courses are processed.
4. If the result contains all courses, return it; otherwise, return [].

---------------------------------
Time Complexity:
O(V + E), where
- V = number of courses,
- E = number of prerequisites.
We visit each course and edge once.

Space Complexity:
O(V + E), for adjacency list, in-degree array, and queue.

---------------------------------
Python Solution:
---------------------------------

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # Step 1: Build adjacency list and in-degree array
        graph = [[] for _ in range(numCourses)]
        indegree = [0] * numCourses

        for course, prereq in prerequisites:
            graph[prereq].append(course)
            indegree[course] += 1

        # Step 2: Start with courses having in-degree 0
        queue = []
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)

        result = []

        # Step 3: Process queue
        while queue:
            curr = queue.pop(0)
            result.append(curr)

            for neighbor in graph[curr]:
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    queue.append(neighbor)

        # Step 4: Check if ordering is valid
        if len(result) == numCourses:
            return result
        else:
            return []
