# 102. Binary Tree Level Order Traversal

## Problem Statement
Given the root of a binary tree, return the level order traversal of its nodes' values.  
(Level order traversal means visiting nodes level by level from left to right).

---

## Example 1
Input:
    3
   / \
  9  20
    /  \
   15   7

Output:
[[3],[9,20],[15,7]]

---

## Example 2
Input: root = [1]  
Output: [[1]]

---

## Example 3
Input: root = []  
Output: []

---

## Constraints
- The number of nodes in the tree is in the range [0, 2000].
- -1000 <= Node.val <= 1000

---

## Approach
1. Use a queue (FIFO) to traverse the tree level by level.  
2. For each level:
   - Count how many nodes are at this level.  
   - Process all nodes of that level, storing their values.  
   - Add their children to the queue for the next level.  
3. Repeat until no nodes remain in the queue.  

---

## Complexity Analysis
- Time Complexity: O(n) → Each node is visited once.  
- Space Complexity: O(n) → Queue stores up to n nodes in the worst case.  

---

## Solution (Python)
```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def levelOrder(self, root: TreeNode):
        if not root:
            return []

        result = []
        queue = [root]  # Start with the root in the queue

        while queue:
            level_size = len(queue)  # Number of nodes at current level
            level = []  # Stores values for this level

            for _ in range(level_size):
                node = queue.pop(0)  # Remove from front of queue
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)  # Add this level to result

        return result
