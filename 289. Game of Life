LeetCode Problem 289: Game of Life
Difficulty: Medium

-----------------------------------------------------------
Problem Statement:
According to the rules of Conway's Game of Life, calculate 
the next state of a given board. The board is a 2D grid 
where each cell has two states:
   - 1 (live)
   - 0 (dead)

Rules:
1. Any live cell with fewer than 2 live neighbors dies 
   (underpopulation).
2. Any live cell with 2 or 3 live neighbors lives 
   (survival).
3. Any live cell with more than 3 live neighbors dies 
   (overpopulation).
4. Any dead cell with exactly 3 live neighbors becomes 
   live (reproduction).

The next state is created by applying these rules to every 
cell simultaneously.

Example 1:
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

Example 2:
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]
-----------------------------------------------------------

âœ… Approach:
1. The challenge is updating the board "in-place" 
   (without using another grid).

2. Trick:
   - Use extra states (markers) to track changes:
     * 1 â†’ -1 means "was alive, now dead".
     * 0 â†’  2 means "was dead, now alive".

   - Why? Because while checking neighbors, we still need 
     to know the *original* state of the cell.

3. Steps:
   - First pass: Apply rules using markers (-1, 2).
   - Second pass: Convert markers back:
       * -1 â†’ 0
       *  2 â†’ 1
-----------------------------------------------------------

class Solution:
    def gameOfLife(self, board):
        rows = len(board)
        cols = len(board[0])

        # Helper to count live neighbors
        def count_live_neighbors(r, c):
            directions = [(-1,-1), (-1,0), (-1,1),
                          (0,-1),         (0,1),
                          (1,-1),  (1,0), (1,1)]
            count = 0
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    # abs(board[nr][nc]) == 1 â†’ originally alive
                    if abs(board[nr][nc]) == 1:
                        count += 1
            return count

        # Step 1: Apply rules with markers
        for r in range(rows):
            for c in range(cols):
                live_neighbors = count_live_neighbors(r, c)

                # Rule 1 & 3: Live cell dies
                if board[r][c] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[r][c] = -1  # was alive, now dead

                # Rule 4: Dead cell becomes alive
                if board[r][c] == 0 and live_neighbors == 3:
                    board[r][c] = 2   # was dead, now alive

        # Step 2: Finalize the board
        for r in range(rows):
            for c in range(cols):
                if board[r][c] > 0:
                    board[r][c] = 1
                else:
                    board[r][c] = 0

-----------------------------------------------------------
ðŸ“Š Time Complexity: O(m * n)
- Each cell and its neighbors are checked.

ðŸ§  Space Complexity: O(1)
- In-place update using markers, no extra board needed.
-----------------------------------------------------------
