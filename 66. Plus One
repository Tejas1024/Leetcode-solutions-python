"""
LeetCode 66. Plus One

📝 Question:
You are given a large integer represented as an integer array `digits`, 
where each `digits[i]` is the ith digit of the integer. 
The digits are ordered from most significant to least significant in left-to-right order. 
The large integer does not contain any leading 0.

Increment the large integer by one and return the resulting array of digits.

Example 1:
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The integer is 123 → plus one → 124.

Example 2:
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The integer is 4321 → plus one → 4322.

Example 3:
Input: digits = [9]
Output: [1,0]
Explanation: The integer is 9 → plus one → 10.


-----------------------------------------------------------
✅ Approach:
- Start from the last digit (least significant).
- Add 1 to it.
- If it becomes < 10, return the array.
- If it becomes 10, set current digit = 0 and carry over 1 to next digit.
- If all digits are processed and we still have a carry, insert 1 at the beginning.

⚡ Example:
digits = [9,9]
Step 1: last 9 → becomes 0, carry = 1
Step 2: second 9 → becomes 0, carry = 1
Step 3: add 1 at front → [1,0,0]

-----------------------------------------------------------
💻 Solution:
"""

class Solution:
    def plusOne(self, digits: list[int]) -> list[int]:
        n = len(digits)
        
        # Traverse from last digit
        for i in range(n - 1, -1, -1):
            if digits[i] < 9:
                digits[i] += 1
                return digits
            digits[i] = 0
        
        # If all were 9, we need an extra digit
        return [1] + digits


"""
-----------------------------------------------------------
⏱️ Time Complexity: O(n)  
   - In worst case, we traverse all digits (like [9,9,9]).

💾 Space Complexity: O(1)  
   - No extra space except modifying input list.
-----------------------------------------------------------
"""
