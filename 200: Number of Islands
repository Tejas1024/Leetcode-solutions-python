"""
LeetCode 200: Number of Islands
--------------------------------
Problem:
Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), 
return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands 
horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example:
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3

---------------------------------------------------
Approach 1: DFS (Depth-First Search)
- Traverse the grid cell by cell.
- When we find a '1', we increment the island counter.
- Use DFS to "sink" all connected land (turn into '0').
- Continue until entire grid is processed.

Time Complexity: O(M × N) → each cell visited once
Space Complexity: O(M × N) in recursion stack (worst case)

---------------------------------------------------
Approach 2: BFS (Breadth-First Search)
- Similar to DFS, but use a queue instead of recursion.
- When we find land, push it into a queue and explore until all connected land is marked as water.

Time Complexity: O(M × N)
Space Complexity: O(min(M, N)) → BFS queue in worst case
"""

class Solution:
    # DFS Solution
    def numIslands(self, grid):
        if not grid:
            return 0
        
        rows, cols = len(grid), len(grid[0])
        count = 0

        def dfs(r, c):
            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == "0":
                return
            grid[r][c] = "0"  # mark visited
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == "1":
                    count += 1
                    dfs(r, c)
        
        return count


class SolutionBFS:
    # BFS Solution (without collections.deque import, manual queue)
    def numIslands(self, grid):
        if not grid:
            return 0
        
        rows, cols = len(grid), len(grid[0])
        count = 0

        def bfs(r, c):
            queue = [(r, c)]
            grid[r][c] = "0"
            while queue:
                cr, cc = queue.pop(0)  # simulate queue
                for nr, nc in [(cr+1, cc), (cr-1, cc), (cr, cc+1), (cr, cc-1)]:
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == "1":
                        grid[nr][nc] = "0"
                        queue.append((nr, nc))

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == "1":
                    count += 1
                    bfs(r, c)
        
        return count
