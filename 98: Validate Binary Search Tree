"""
LeetCode Problem 98: Validate Binary Search Tree

ðŸ”¹ Problem:
Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as:
1. The left subtree of a node contains only nodes with keys less than the node's key.
2. The right subtree of a node contains only nodes with keys greater than the node's key.
3. Both the left and right subtrees must also be binary search trees.

ðŸ”¹ Example:
Input: root = [2,1,3]
Output: True

Input: root = [5,1,4,null,null,3,6]
Output: False
Explanation: The root node's value is 5 but the right child's value is 4.

ðŸ”¹ Approach:
We recursively validate the tree using a helper function that checks whether each nodeâ€™s value 
lies within a valid range (low, high). 
- For left child: range is (low, node.val)
- For right child: range is (node.val, high)
If any node violates these constraints, the tree is not a valid BST.

ðŸ”¹ Time Complexity: O(n) â†’ we visit each node once.
ðŸ”¹ Space Complexity: O(h) â†’ recursion stack, where h is the tree height.
"""

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def validate(node, low=float("-inf"), high=float("inf")):
            if not node:
                return True

            # Current node must be within the valid range
            if not (low < node.val < high):
                return False

            # Left child must be less than node.val
            # Right child must be greater than node.val
            return (validate(node.left, low, node.val) and
                    validate(node.right, node.val, high))

        return validate(root)
