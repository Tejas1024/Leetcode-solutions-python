LeetCode 63. Unique Paths II  

üìù Question:  
A robot is located at the top-left corner of an `m x n` grid.  
The robot can only move **down or right** at any point. Some cells are obstacles (marked as `1`), empty cells are `0`.  

Return the number of unique paths from top-left to bottom-right.  

Example 1:  
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]  
Output: 2  
Explanation: There are two paths avoiding the obstacle.  

Example 2:  
Input: obstacleGrid = [[0,1],[0,0]]  
Output: 1  


-----------------------------------------------------------
‚úÖ Approach: Dynamic Programming (In-Place)

- Use the grid itself as DP table.  
- For each cell `(i,j)`:
  - If `obstacleGrid[i][j] == 1`, mark `0` (cannot pass).  
  - Otherwise, `obstacleGrid[i][j] = paths from top + paths from left`.  
- Base case: start cell = 1 if no obstacle.  

‚ö° Key Trick:  
Handle first row and first column carefully ‚Üí if any obstacle, remaining cells in that row/column = 0  


-----------------------------------------------------------
üíª Solution:
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])

        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    obstacleGrid[i][j] = 0
                elif i == 0 and j == 0:
                    obstacleGrid[i][j] = 1
                elif i == 0:
                    obstacleGrid[i][j] = obstacleGrid[i][j-1]
                elif j == 0:
                    obstacleGrid[i][j] = obstacleGrid[i-1][j]
                else:
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]

        return obstacleGrid[m-1][n-1]


-----------------------------------------------------------
‚è±Ô∏è Time Complexity: O(m * n)  
   - Each cell is visited once.  

üíæ Space Complexity: O(1)  
   - In-place DP, no extra space needed.  
-----------------------------------------------------------
