LeetCode 56. Merge Intervals  

📝 Question:  
Given an array of intervals where `intervals[i] = [starti, endi]`, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.  

Example 1:  
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]  
Output: [[1,6],[8,10],[15,18]]  
Explanation: Intervals [1,3] and [2,6] overlap → merge to [1,6].  

Example 2:  
Input: intervals = [[1,4],[4,5]]  
Output: [[1,5]]  
Explanation: Intervals [1,4] and [4,5] touch → merge to [1,5].  


-----------------------------------------------------------
✅ Approach: Sorting + Merge  

1. Sort intervals by start time.  
2. Initialize `merged` list with the first interval.  
3. Iterate through remaining intervals:  
   - If current interval start <= last merged interval end → overlap → merge:  
     `merged[-1][1] = max(merged[-1][1], current_end)`  
   - Else → no overlap → append current interval.  

⚡ Key Trick:  
Sorting ensures overlapping intervals are adjacent → can merge in one pass.  


-----------------------------------------------------------
💻 Solution:
class Solution:
    def merge(self, intervals: list[list[int]]) -> list[list[int]]:
        if not intervals:
            return []

        # Step 1: Sort intervals by start
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]

        # Step 2: Merge intervals
        for current in intervals[1:]:
            if current[0] <= merged[-1][1]:  # overlap
                merged[-1][1] = max(merged[-1][1], current[1])
            else:  # no overlap
                merged.append(current)

        return merged

-----------------------------------------------------------
⏱️ Time Complexity: O(n log n)  
   - Sorting takes O(n log n), merging takes O(n)  

💾 Space Complexity: O(n)  
   - Result list stores merged intervals  
-----------------------------------------------------------
