LeetCode 56. Merge Intervals  

ğŸ“ Question:  
Given an array of intervals where `intervals[i] = [starti, endi]`, merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.  

Example 1:  
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]  
Output: [[1,6],[8,10],[15,18]]  
Explanation: Intervals [1,3] and [2,6] overlap â†’ merge to [1,6].  

Example 2:  
Input: intervals = [[1,4],[4,5]]  
Output: [[1,5]]  
Explanation: Intervals [1,4] and [4,5] touch â†’ merge to [1,5].  


-----------------------------------------------------------
âœ… Approach: Sorting + Merge  

1. Sort intervals by start time.  
2. Initialize `merged` list with the first interval.  
3. Iterate through remaining intervals:  
   - If current interval start <= last merged interval end â†’ overlap â†’ merge:  
     `merged[-1][1] = max(merged[-1][1], current_end)`  
   - Else â†’ no overlap â†’ append current interval.  

âš¡ Key Trick:  
Sorting ensures overlapping intervals are adjacent â†’ can merge in one pass.  


-----------------------------------------------------------
ğŸ’» Solution:
class Solution:
    def merge(self, intervals: list[list[int]]) -> list[list[int]]:
        if not intervals:
            return []

        # Step 1: Sort intervals by start
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]

        # Step 2: Merge intervals
        for current in intervals[1:]:
            if current[0] <= merged[-1][1]:  # overlap
                merged[-1][1] = max(merged[-1][1], current[1])
            else:  # no overlap
                merged.append(current)

        return merged

-----------------------------------------------------------
â±ï¸ Time Complexity: O(n log n)  
   - Sorting takes O(n log n), merging takes O(n)  

ğŸ’¾ Space Complexity: O(n)  
   - Result list stores merged intervals  
-----------------------------------------------------------
