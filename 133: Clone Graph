"""
LeetCode Problem 133: Clone Graph
---------------------------------
Problem Statement:
Given a reference of a node in a connected undirected graph. 
Return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.

Example:
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]

Explanation:
The original graph is:
    1 -- 2
    |    |
    4 -- 3
The cloned graph should look the same.

Constraints:
- The number of nodes in the graph is in the range [0, 100].
- 1 <= Node.val <= 100
- Node.val is unique for each node.
- There are no repeated edges and no self-loops.
- The Graph is connected.

---------------------------------
Approach:
1. Use DFS to traverse the graph.
2. Maintain a dictionary (hashmap) that maps original nodes to their cloned copies.
3. For each node, clone it if not already cloned.
4. Recursively (DFS) clone its neighbors.
5. Return the cloned graph starting from the given node.

---------------------------------
Time Complexity:
O(N + E), where
- N = number of nodes,
- E = number of edges.
We visit each node and edge once.

Space Complexity:
O(N), for storing the hashmap of cloned nodes and recursion stack in DFS.
"""

# Definition for a Node in the graph.
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None

        # Dictionary to map original nodes -> cloned nodes
        cloned = {}

        def dfs(curr):
            if curr in cloned:
                return cloned[curr]

            # Clone the current node
            copy = Node(curr.val)
            cloned[curr] = copy

            # Clone neighbors
            for neighbor in curr.neighbors:
                copy.neighbors.append(dfs(neighbor))

            return copy

        return dfs(node)Time Complexity:
O(N + E), where
- N = number of nodes,
- E = number of edges.
We visit each node and edge once.

Space Complexity:
O(N), for storing the hashmap of cloned nodes and recursion stack in DFS.

"""

# Definition for a Node in the graph.
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None

        # Dictionary to store cloned nodes
        cloned = {}

        # DFS function
        def dfs(curr):
            if curr in cloned:
                return cloned[curr]

            # Clone the current node
            copy = Node(curr.val)
            cloned[curr] = copy

            # Clone neighbors
            for neighbor in curr.neighbors:
                copy.neighbors.append(dfs(neighbor))

            return copy

        return dfs(node)
