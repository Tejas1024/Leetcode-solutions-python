LeetCode 139. Word Break  

üìù Question:  
Given a string `s` and a dictionary of strings `wordDict`, return true if `s` can be segmented  
into a space-separated sequence of one or more dictionary words.  

Example 1:  
Input: s = "leetcode", wordDict = ["leet","code"]  
Output: true  
Explanation: "leetcode" can be segmented as "leet code".  

Example 2:  
Input: s = "applepenapple", wordDict = ["apple","pen"]  
Output: true  
Explanation: "applepenapple" = "apple pen apple".  

Example 3:  
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]  
Output: false  


-----------------------------------------------------------
‚úÖ Approach: Dynamic Programming  

- We want to check if the string `s` can be segmented into valid words.  
- Define `dp[i]` ‚Üí whether `s[:i]` (substring up to index i) can be segmented.  
- Initialization: `dp[0] = True` (empty string is valid).  
- Transition:  
  For each `i` from 1..n ‚Üí check all possible splits:  
  if `dp[j]` is True and `s[j:i]` is in wordDict ‚Üí mark `dp[i] = True`.  

‚ö° Key Trick:  
Instead of checking every substring against the list, use a **set** for O(1) lookup.  


-----------------------------------------------------------
üíª Solution:

class Solution:
    def wordBreak(self, s: str, wordDict: list[str]) -> bool:
        word_set = set(wordDict)  # faster lookup
        n = len(s)
        
        dp = [False] * (n + 1)
        dp[0] = True  # base case
        
        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break  # no need to check further splits
        
        return dp[n]

-----------------------------------------------------------
‚è±Ô∏è Time Complexity: O(n^2)  
   - For each i, we check all j splits.  

üíæ Space Complexity: O(n)  
   - DP array of size n+1.  
-----------------------------------------------------------
